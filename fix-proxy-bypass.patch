diff --git a/electroncash/network.py b/electroncash/network.py
index 63a0a78aa..062c43144 100644
--- a/electroncash/network.py
+++ b/electroncash/network.py
@@ -1,5 +1,6 @@
 # Electrum - Lightweight Bitcoin Client
 # Copyright (c) 2011-2016 Thomas Voegtlin
+# Copyright (C) 2017-2020 The Electron Cash Developers
 #
 # Permission is hereby granted, free of charge, to any person
 # obtaining a copy of this software and associated documentation files
@@ -44,7 +45,7 @@ from .i18n import _
 from .interface import Connection, Interface
 from . import blockchain
 from . import version
-from .tor import TorController
+from .tor import TorController, check_proxy_bypass_tor_control
 from .utils import Event
 
 DEFAULT_AUTO_CONNECT = True
@@ -190,6 +191,23 @@ def serialize_server(host, port, protocol):
     return str(':'.join([host, port, protocol]))
 
 
+bypass_proxy_filters = [check_proxy_bypass_tor_control]
+
+
+def _socksocket_filtered(*args, **kwargs):
+    """
+    This function checks bypass_proxy_filters and if any of the filters returns true
+    a raw socket will be returned, otherwise a socks socket will be returned.
+    """
+    if any(f(*args, **kwargs) for f in bypass_proxy_filters):
+        if socket._socketobject:
+            return socket._socketobject(*args, **kwargs)
+        else:
+            return socket.socket(*args, **kwargs)
+    else:
+        return socks.socksocket(*args, **kwargs)
+
+
 class Network(util.DaemonThread):
     """The Network class manages a set of connections to remote electrum
     servers, each connected socket is handled by an Interface() object.
@@ -619,7 +637,7 @@ class Network(util.DaemonThread):
                                   # socks.py seems to want either None or a non-empty string
                                   username=(proxy.get("user", "") or None),
                                   password=(proxy.get("password", "") or None))
-            socket.socket = socks.socksocket
+            socket.socket = _socksocket_filtered
             # prevent dns leaks, see http://stackoverflow.com/questions/13184205/dns-over-proxy
             socket.getaddrinfo = lambda *args: [(socket.AF_INET, socket.SOCK_STREAM, 6, '', (args[0], args[1]))]
         else:
diff --git a/electroncash/tor/__init__.py b/electroncash/tor/__init__.py
index c6b95c2f5..990c3dcca 100644
--- a/electroncash/tor/__init__.py
+++ b/electroncash/tor/__init__.py
@@ -1,5 +1,5 @@
 # Electron Cash - lightweight Bitcoin client
-# Copyright (C) 2019 Axel Gembe <derago@gmail.com>
+# Copyright (C) 2019, 2020 Axel Gembe <derago@gmail.com>
 #
 # Permission is hereby granted, free of charge, to any person
 # obtaining a copy of this software and associated documentation files
@@ -21,4 +21,4 @@
 # CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 # SOFTWARE.
 
-from .controller import TorController
+from .controller import TorController, check_proxy_bypass_tor_control
diff --git a/electroncash/tor/controller.py b/electroncash/tor/controller.py
index 11c39095a..eb3c09009 100644
--- a/electroncash/tor/controller.py
+++ b/electroncash/tor/controller.py
@@ -1,5 +1,5 @@
 # Electron Cash - lightweight Bitcoin client
-# Copyright (C) 2019 Axel Gembe <derago@gmail.com>
+# Copyright (C) 2019, 2020 Axel Gembe <derago@gmail.com>
 #
 # Permission is hereby granted, free of charge, to any person
 # obtaining a copy of this software and associated documentation files
@@ -28,6 +28,7 @@ import sys
 import threading
 import shutil
 import socket
+import inspect
 from enum import IntEnum, unique
 from typing import Tuple, Optional
 
@@ -41,19 +42,6 @@ from ..util import PrintError
 from ..utils import Event
 from ..simple_config import SimpleConfig
 
-# The network code monkey patches socket to use a SOCKS socket in Network.set_proxy.
-# This causes the Tor control connection to go through Tor, which is not a good idea.
-# To work around this, we monkey patch Stem to always create a standard socket for the
-# control connection.
-_orig_socket = socket.socket
-def _make_socket_monkey_patch(self):
-    try:
-        control_socket = _orig_socket(socket.AF_INET, socket.SOCK_STREAM)
-        control_socket.connect((self.address, self.port))
-        return control_socket
-    except socket.error as exc:
-        raise stem.SocketError(exc)
-stem.socket.ControlPort._make_socket = _make_socket_monkey_patch
 
 _TOR_ENABLED_KEY = 'tor_enabled'
 _TOR_ENABLED_DEFAULT = False
@@ -61,6 +49,24 @@ _TOR_ENABLED_DEFAULT = False
 _TOR_SOCKS_PORT_KEY = 'tor_socks_port'
 _TOR_SOCKS_PORT_DEFAULT = 0
 
+
+def check_proxy_bypass_tor_control(*args, **kwargs) -> bool:
+    """
+    This function returns True when called by stem.socket.ControlPort to prevent
+    the Tor control connection going through a proxied socket.
+    """
+    stack = inspect.stack()
+    if stack and len(stack) >= 4:
+        # [0] is this function, [1] is the genexpr in _socksocket_filtered,
+        # [2] is _socksocket_filtered and [3] is the caller. In newer stem
+        # versions socket is not called directly but through asyncio.
+        for s in stack[3:7]:
+            caller_self = stack[3].frame.f_locals.get('self')
+            if caller_self and type(caller_self) is stem.socket.ControlPort:
+                return True
+    return False
+
+
 class TorController(PrintError):
     @unique
     class Status(IntEnum):
